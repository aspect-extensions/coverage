"""
Implement a 'coverage' task that wraps a test command.

Gathers the coverage.dat files to power common developer workflows.
"""

load("./runnable.axl", "runnable")

# buildifier: disable=function-docstring
def impl(ctx) -> int:
    out = ctx.std.io.stdout
    err = ctx.std.io.stderr

    lcov_build = ctx.bazel.build(
        "@lcov",
        build_events = True,
        flags = ["--build_runfile_links"],
    )
    
    lcov = runnable(ctx)
    for event in lcov_build.build_events():
        lcov.event(event)

    test = ctx.bazel.test(
        "//...",
        build_events = True,
        flags = [
            "--isatty=" + str(int(out.is_tty)),
            "--collect_code_coverage",
        ],
    )

    coverage_dat_files = []
    for event in test.build_events():
        if event.kind == "test_result":
            coverage_dat_files.extend([
                f.file.removeprefix("file://")
                for f in event.payload.test_action_output
                if f.file.endswith("coverage.dat")
            ])
        # TODO: populate a GITHUB_OUTPUT variable so we can use https://github.com/codecov/codecov-action
        if event.kind == "progress":
            out.write(event.payload.stdout)
            err.write(event.payload.stderr)
            
    test.wait()

    # TODO: get the delta of changed files from VCS, and render 'incremental' coverage as the default presentation
    exit = lcov.spawn(ctx, ["--list"] + coverage_dat_files).wait()

    if not exit.success:
        err.write("\x1b[0;31mERROR\x1b[0m: process exited with code %d\n" % exit.code)

    # Async: Cleanup disk space consumed by the .dat files.
    ctx.std.process.command("rm").arg("-f").args(coverage_dat_files).spawn()
    return 0

coverage = task(
    implementation = impl,
    args = {
        "targets": args.positional(),
    }
)
